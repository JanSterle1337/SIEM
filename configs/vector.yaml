sources:
  nginx_logs:
    type: file
    include:
      - /var/log/siem/logs/nginx/access.log
    read_from: beginning
  api_logs:
    type: file
    include:
      - /var/log/siem/logs/apps/api.log
    read_from: beginning
  auth_logs:
    type: file
    include:
      - /var/log/siem/logs/auth/secure.log
    read_from: beginning
  firewall_logs:
    type: file
    include:
      - /var/log/siem/logs/firewall/trace.log
    read_from: beginning
  syslog_logs:
    type: file
    include:
      - /var/log/siem/logs/system/syslog.log
    read_from: beginning
  host_telemetry:
    type: host_metrics
    collectors:
      - cpu
      - memory
      - disk
      - network
    scrape_interval_secs: 15
transforms:
  ocsf_http:
    type: remap
    inputs:
      - nginx_logs
    source: |
      # Updated Regex with Optional Trace ID
      # (?: ...)? makes the trailing space and quoted trace_id optional
      http_regex = r'^(?P<ip>[\d\.]+) - - \[(?P<ts>.*?)\] "(?P<method>\w+) (?P<path>.*?) .*?" (?P<status>\d+) (?P<size>\d+) "(?P<ref>.*?)" "(?P<agent>.*?)"(?:\s+"(?P<trace_id>.*?)")?$'
      
      parsed, err = parse_regex(.message, http_regex)

      if err == null {
          . = {}
          .metadata = {}
          .src_endpoint = {}
          .http_request = {}
          .http_request.url = {}
          .http_response = {}

          .metadata.version = "1.1.0"
          .class_uid = 4002
          .class_name = "HTTP Activity"
          .time = parse_timestamp!(parsed.ts, format: "%d/%b/%Y:%H:%M:%S %z")

          .src_endpoint.ip = parsed.ip
          .http_request.method = parsed.method
          .http_request.url.path = parsed.path
          .http_request.user_agent = parsed.agent
          .http_response.status = to_int!(parsed.status)
          
          # Only map trace_id if it exists in the log line
          if parsed.trace_id != null && parsed.trace_id != "" {
              .trace_id = parsed.trace_id
          }
          
          .severity_id = if to_int!(parsed.status) >= 400 { 3 } else { 1 }
      } else {
          .class_uid = 0
          .class_name = "Unknown"
          .debug_msg = .message
      }
  ocsf_api:
    type: remap
    inputs:
      - api_logs
    source: |
      parts, err = split(.message, " api-srv: ")

      if err == null && length(parts) > 1 {
          ts_part = parts[0]
          kv_part = parts[1]
          parsed = parse_key_value!(kv_part)
          
          . = {}
          .metadata = {}
          .api = {}
          .http_response = {}

          .metadata.version = "1.1.0"
          .class_uid = 6003
          .class_name = "API Activity"
          .time = parse_timestamp!(ts_part, format: "%FT%T.%f")
          
          .api.method = parsed.method
          .api.endpoint = parsed.endpoint
          .http_response.status = to_int!(parsed.status)
          .trace_id = parsed.trace_id
          
          # Use ! to tell Vector to abort if 'latency' is missing/invalid
          lat_val = replace!(parsed.latency, "ms", "")
          .duration = to_int!(lat_val)
      } else {
          abort
      }
  ocsf_auth:
    type: remap
    inputs:
      - auth_logs
    source: |
      # 1. PRE-INITIALIZE OCSF
      .metadata.version = "1.1.0"
      current_year = slice!(to_string(now()), 0, 4)
      
      # 2. REGEX PATTERNS
      auth_regex = r'^(?P<ts>\w+\s+\d+\s+\d+:\d+:\d+)\s+(?P<host>[^\s]+)\s+sshd\[(?P<pid>\d+)\]:\s+(?P<msg>Accepted|Failed)\s+password\s+for\s+(?P<user>[^\s]+)\s+from\s+(?P<ip>[\d\.]+)\s+port\s+(?P<port>\d+).*$'
      acct_regex = r'^(?P<ts>\w+\s+\d+\s+\d+:\d+:\d+)\s+(?P<host>[^\s]+)\s+(?P<app>[^\[\s:]+)(?:\[(?P<pid>\d+)\])?:\s+(?P<detail>.*)$'

      # 3. ATTEMPT PARSING
      auth_parsed = parse_regex(.message, auth_regex) ?? null
      acct_parsed = parse_regex(.message, acct_regex) ?? null

      if auth_parsed != null {
          .class_uid = 3002
          .class_name = "Authentication"
          .category_name = "Identity & Access Management"
          
          # Added ! to replace to handle the fallible error
          ts_clean = replace!(auth_parsed.ts, r'\s+', " ")
          ts_with_year = "#{current_year} #{ts_clean}"
          .time = parse_timestamp(ts_with_year, format: "%Y %b %e %H:%M:%S") ?? now()

          .status = if auth_parsed.msg == "Accepted" { "Success" } else { "Failure" }
          .status_id = if auth_parsed.msg == "Accepted" { 1 } else { 2 }
          
          .user.name = auth_parsed.user
          .src_endpoint.ip = auth_parsed.ip
          .src_endpoint.port = to_int!(auth_parsed.port)
          .device.hostname = auth_parsed.host
          .severity_id = if .status_id == 2 { 3 } else { 1 }
          .message = to_string(auth_parsed.msg) + " password for " + to_string(auth_parsed.user)

      } else if acct_parsed != null {
          .class_uid = 3001
          .class_name = "Account Change"
          
          # Added ! to replace here too
          ts_clean = replace!(acct_parsed.ts, r'\s+', " ")
          ts_with_year = "#{current_year} #{ts_clean}"
          .time = parse_timestamp(ts_with_year, format: "%Y %b %e %H:%M:%S") ?? now()

          .device.hostname = acct_parsed.host
          .activity_name = acct_parsed.app
          
          detail_str = string!(acct_parsed.detail)
          if contains(detail_str, "name=") {
              parts = split(detail_str, "name=")
              if length(parts) > 1 { .user.name = parts[1] }
          } else if contains(detail_str, "for ") {
              parts = split(detail_str, "for ")
              if length(parts) > 1 { .user.name = parts[1] }
          }
          
          .message = detail_str
          .severity_id = 2 

      } else {
          .class_uid = 1001 
          .class_name = "System Activity"
          .time = now()
          .message = .message
          .status = "Unparsed Auth Log"
          .severity_id = 1
      }

      # 4. FINAL CLEANUP
      del(.source_type)
      del(.timestamp)
      del(.file)
      del(.host)

  ocsf_network:
    type: remap
    inputs:
      - firewall_logs
    source: |
      # Pattern: TS Host filter: ACTION PROTO SRC_IP:PORT -> DST_IP:PORT (policy: POLICY)
      fw_regex = r'^(?P<ts>[\d\-T:\.]+)\s+(?P<host>[^\s]+)\s+filter:\s+(?P<action>\w+)\s+(?P<proto>\w+)\s+(?P<src_ip>[\d\.]+):(?P<src_port>\d+)\s+->\s+(?P<dst_ip>[\d\.]+):(?P<dst_port>\d+)\s+\(policy:\s+(?P<policy>[^\)]+)\)$'
      
      parsed, err = parse_regex(.message, fw_regex)
      
      if err == null {
          . = {}
          # Initialize objects to avoid E642
          .metadata = {}
          .connection_info = {}
          .src_endpoint = {}
          .dst_endpoint = {}
          .device = {}
          
          .metadata.version = "1.1.0"
          .class_uid = 4001
          .class_name = "Network Activity"
          .time = parse_timestamp!(parsed.ts, format: "%FT%T.%f")
          
          .status = if parsed.action == "ALLOW" { "Success" } else { "Failure" }
          .disposition = parsed.action
          
          .connection_info.protocol_name = parsed.proto
          .connection_info.boundary = "internal" # Assuming internal for this lab
          
          .src_endpoint.ip = parsed.src_ip
          .src_endpoint.port = to_int!(parsed.src_port)
          
          .dst_endpoint.ip = parsed.dst_ip
          .dst_endpoint.port = to_int!(parsed.dst_port)
          
          .device.hostname = parsed.host
          .severity_id = if parsed.action == "DENY" { 2 } else { 1 }
      } else {
          abort
      }

  ocsf_syslog:
    type: remap
    inputs:
      - syslog_logs
    source: |
      # Updated Regex: Handles both 'app[123]: msg' and 'app: msg' and 'app msg'
      # Pattern: Month Day Time Host App([PID])(?::) Message
      sys_regex = r'^(?P<ts>\w+\s+\d+\s+\d+:\d+:\d+)\s+(?P<host>[^\s]+)\s+(?P<app>[^\[\s:]+)(?:\[(?P<pid>\d+)\])?[:\s]+(?P<msg>.*)$'
      
      parsed, err = parse_regex(.message, sys_regex)
      
      # 1. Initialize OCSF structure immediately to ensure class_uid exists
      .metadata = {"version": "1.1.0"}
      .device = {}
      .process = {}
      
      if err == null {
          msg_str = string!(parsed.msg)

          # 2. Determine Class: 1007 for Process, 1001 for General System
          if parsed.app == "kernel" {
            .class_uid = 1001
            .class_name = "System Activity"
          } else {
            .class_uid = 1007
            .class_name = "Process Activity"
          }
          
          # 3. Handle Timestamp (Syslog doesn't provide the year)
          current_year = to_string(now())
          year = slice!(current_year, 0, 4)
          ts_with_year = "#{year} #{parsed.ts}"
          .time = parse_timestamp(ts_with_year, format: "%Y %b %d %H:%M:%S") ?? now()
          
          # 4. Map Device and Process info
          .device.hostname = parsed.host
          .process.name = parsed.app
          if parsed.pid != null {
              .process.pid = to_int!(parsed.pid)
          }
          
          .message = msg_str
          
          # 5. Severity Logic
          if contains(msg_str, "Kill") || contains(msg_str, "Out of memory") || contains(msg_str, "BLOCK") {
              .severity_id = 4 # Critical
              .status = "Failure"
          } else {
              .severity_id = 1 # Informational
              .status = "Success"
          }
          
          # Clean up the raw message field that Vector adds automatically
          del(.source_type)
          del(.timestamp)

      } else {
          # FALLBACK: If regex fails, we still provide a valid OCSF record
          .class_uid = 1001
          .class_name = "System Activity"
          .message = .message
          .status = "Unparsed"
          .severity_id = 2
          .time = now()
      }

  raw_labeler:
    type: remap
    inputs: ["nginx_logs", "api_logs", "auth_logs", "firewall_logs", "syslog_logs"]
    source: |
      # Ensure .file exists and is a string before checking
      file_path = to_string(.file) ?? ""

      if contains(file_path, "access.log") {
          .label = "nginx"
      } else if contains(file_path, "api.log") {
          .label = "api"
      } else if contains(file_path, "secure.log") {
          .label = "auth"
      } else if contains(file_path, "trace.log") {
          .label = "firewall"
      } else if contains(file_path, "syslog.log") {
          .label = "syslog"
      } else {
          .label = "misc"
      }
  metrics_to_json:
    type: metric_to_log
    inputs: ["host_telemetry"]
  
  metrics_quickwit_map:
    type: remap
    inputs: ["metrics_to_json"]
    source: |
      .timestamp = .timestamp
      .host = .tags.host || "unknown-host"
      .metric_name = .name
      .value = to_float(.gauge.value || .counter.value) ?? 0.0
      
      # Clean up tags and metadata
      del(.tags.host)
      .tags = .tags
      del(.name)
      del(.kind)
      del(.gauge)
      del(.counter)

sinks:
  debug_console:
    type: console
    inputs: ["ocsf_http", "ocsf_api", "ocsf_auth", "ocsf_network", "ocsf_syslog"]
    encoding:
      codec: json
  redpanda_out:
    type: kafka
    inputs:
      - ocsf_*
    bootstrap_servers: 'redpanda:9092'
    topic: ocsf-events
    encoding:
      codec: json
    batch:
      max_bytes: 1048576
  redpanda_raw:
    type: kafka
    inputs: ["raw_labeler"] # Point here!
    bootstrap_servers: 'redpanda:9092'
    topic: 'raw-{{ label }}'
    encoding:
      codec: json
    batch:
      max_bytes: 1048576
  redpanda_metrics:
    type: kafka
    inputs: ["metrics_quickwit_map"]
    bootstrap_servers: 'redpanda:9092'
    topic: 'metrics-raw'
    encoding:
      codec: json
